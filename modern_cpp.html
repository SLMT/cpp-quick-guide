<!DOCTYPE HTML>
<html lang="zh-TW" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Modern C++ (C++11 之後的變化) - 小山的 C++ 快速上手筆記</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">簡介</a></li><li class="chapter-item expanded "><a href="cpp_basics.html"><strong aria-hidden="true">1.</strong> C++ 基礎知識加強</a></li><li class="chapter-item expanded "><a href="cpp_stl.html"><strong aria-hidden="true">2.</strong> C++ STL</a></li><li class="chapter-item expanded "><a href="cpp_oop.html"><strong aria-hidden="true">3.</strong> C++ 物件導向</a></li><li class="chapter-item expanded "><a href="cpp_advanced.html"><strong aria-hidden="true">4.</strong> C++ 進階語法</a></li><li class="chapter-item expanded "><a href="modern_cpp.html" class="active"><strong aria-hidden="true">5.</strong> Modern C++ (C++11 之後的變化)</a></li><li class="chapter-item expanded "><a href="cpp_concurrency.html"><strong aria-hidden="true">6.</strong> C++ Concurrency</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">小山的 C++ 快速上手筆記</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="modern-c-c11-之後的變化"><a class="header" href="#modern-c-c11-之後的變化">Modern C++ (C++11 之後的變化)</a></h1>
<h2 id="棄用語法"><a class="header" href="#棄用語法">棄用語法</a></h2>
<ul>
<li>字串 literal 應該改用 <code>const char *</code> 型別而不是 <code>char *</code> 型別宣告</li>
<li><code>register</code> 的效果被移除（不再具有將變數放入 CPU register 的效果）</li>
<li><code>bool</code> 不可以 <code>++</code></li>
<li>C 語言風格的轉換方式 <code>(type)</code> 被棄用，應該改用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 等方式轉換</li>
</ul>
<h2 id="新增語法"><a class="header" href="#新增語法">新增語法</a></h2>
<p>C++11：</p>
<ul>
<li>
<p>指定 Null Pointer 應改用 <code>nullptr</code> 而不是 <code>NULL</code></p>
<ul>
<li><code>NULL</code> 可能會被解析成 <code>int</code> 造成額外問題，例如有兩個 function 分別為 <code>foo(int a)</code> 與 <code>foo(char* b)</code>，當我們呼叫 <code>foo(NULL)</code> 就不見得會呼叫 <code>foo(char* b)</code> 那個。</li>
</ul>
</li>
<li>
<p>加入 <code>constexpr</code>：用來表示某一個 expression 或 function 輸出的結果是一個常數</p>
<ul>
<li>
<p>編譯器會去驗證這點，並且可以以此來優化程式碼</p>
</li>
<li>
<p>範例：</p>
<pre><code class="language-cpp">constexpr int fibonacci(const int n) {
    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);
}
</code></pre>
<pre><code class="language-cpp">constexpr int var_constexpr = 1 + 2 + 3;
</code></pre>
</li>
</ul>
</li>
<li>
<p>提供可以使用 initialization list 初始化任意物件的能力（但需要實作對應的 constructor）</p>
<ul>
<li>範例：
<pre><code class="language-cpp">#include &lt;initializer_list&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

class MagicFoo {
public:
    std::vector&lt;int&gt; vec;
    MagicFoo(std::initializer_list&lt;int&gt; list) {
        for (std::initializer_list&lt;int&gt;::iterator it = list.begin();
            it != list.end(); ++it)
            vec.push_back(*it);
    }
};
int main() {
    // after C++11
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout &lt;&lt; "magicFoo: ";
    for (std::vector&lt;int&gt;::iterator it = magicFoo.vec.begin(); 
        it != magicFoo.vec.end(); ++it) 
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加入 <code>auto</code> ：自動型別推導</p>
<pre><code class="language-cpp">auto i = 5;              // i is inferred as int
auto arr = new auto(10); // arr is inferred as int *
</code></pre>
<ul>
<li>
<p><code>auto</code> 也常用於 template 指定 function return type 時，這樣就不需要額外定義另一個 type 變數：</p>
<pre><code class="language-cpp">// Old way
template&lt;typename R, typename T, typename U&gt;
R add(T x, U y) {
    return x + y;
}

// After C++11
template&lt;typename T, typename U&gt;
auto add(T x, U y){
    return x + y;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加入 <code>decltype</code> ： 輸出變數是何種型別</p>
<ul>
<li>
<p>通常搭配 <code>std::is_same&lt;T, U&gt;</code> 使用，檢查是否兩個型別是同一個型別</p>
<pre><code class="language-cpp">auto x = 1;
if (std::is_same&lt;decltype(x), int&gt;::value)
    std::cout &lt;&lt; "type x == int" &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
</li>
<li>
<p>Ranged for loop</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
for (auto element : vec)
    std::cout &lt;&lt; element &lt;&lt; std::endl; // read only
for (auto &amp;element : vec) {
    element += 1;                      // writeable
}
</code></pre>
<ul>
<li>宣告 ranged for loop 變數的原則：
<ul>
<li>想 copy 數值 =&gt; 使用 <code>auto x</code></li>
<li>想直接引用原本的物件，並且可能會修改 =&gt; 使用 <code>auto &amp;x</code></li>
<li>想直接引用原本的物件，但不會修改 =&gt; 使用 <code>auto const &amp;x</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>搭配 <code>template</code> 使用別名：</p>
<pre><code class="language-cpp">template&lt;typename T, typename U&gt;
class MagicType {
public:
    T dark;
    U magic;
};

template&lt;typename T&gt;
using TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;

int main() {
    TrueDarkMagic&lt;bool&gt; you;
}
</code></pre>
</li>
<li>
<p>Template 變動變數清單：</p>
<pre><code class="language-cpp">template&lt;typename... Ts&gt;
void magic(Ts... args) {
    std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl;
}

magic(); // Print: 0
magic(1); // Print: 1
magic(1, ""); // Print: 2
</code></pre>
</li>
<li>
<p>Delegate constructor：允許重複使用同一個 class 內的 constructor</p>
<pre><code class="language-cpp">class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() { // delegate Base() constructor
        value2 = value;
    }
};
</code></pre>
</li>
<li>
<p>繼承 constructor：使用 <code>using</code> 關鍵字來使用 base class 的 constructor</p>
<pre><code class="language-cpp">class Subclass : public Base {
public:
    using Base::Base; // inheritance constructor
};
</code></pre>
</li>
<li>
<p>加入 <code>override</code> : 強制檢查是否複寫不存在的 virtual function</p>
<pre><code class="language-cpp">struct Base {
    virtual void foo(int);
};
struct SubClass: Base {
    virtual void foo(int) override; // legal
    virtual void foo(float) override; // illegal, no such virtual function
};
</code></pre>
</li>
<li>
<p>加入 <code>final</code> : 阻止繼承或 override</p>
<pre><code class="language-cpp">struct Base {
    virtual void foo() final;
};
struct SubClass1 final: Base {
}; // legal

struct SubClass2 : SubClass1 {
}; // illegal, SubClass1 has final

struct SubClass3: Base {
    void foo(); // illegal, foo has final
};
</code></pre>
</li>
<li>
<p>拒絕或明確要求預設實作（用於 constructor 或 operator 等等）：</p>
<pre><code class="language-cpp">class Magic {
    public:
    Magic() = default; // explicit let compiler use default constructor
    Magic&amp; operator=(const Magic&amp;) = delete; // explicit declare refuse constructor
    Magic(int magic_number);
}
</code></pre>
</li>
<li>
<p><code>enum class</code></p>
<ul>
<li>與 <code>enum</code> 不同處在於：
<ul>
<li>不會預設可以轉換為 int</li>
<li>多個 <code>enum class</code> 存在相同名稱的 variant 也不會產生名稱衝突</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">enum class new_enum : unsigned int {
    value1,
    value2,
    value3 = 100,
    value4 = 100
};
</code></pre>
</li>
</ul>
<p>C++17：</p>
<ul>
<li>
<p>可以在 if 條件式宣告變數</p>
<pre><code class="language-cpp">if (const auto itr = std::find(vec.begin(), vec.end(), 3);
    itr != vec.end()) {
    *itr = 4;
}
</code></pre>
</li>
<li>
<p>可以對 if statement 使用 <code>constexpr</code></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename T&gt;
auto print_type_info(const T&amp; t) {
    if constexpr (std::is_integral&lt;T&gt;::value) {
        return t + 1;
    } else {
        return t + 0.001;
    }
}
int main() {
    std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl;
    std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p>宣告變數時可以解構資料，例如下面的 <code>[x, y, z]</code>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;

std::tuple&lt;int, double, std::string&gt; f() {
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto [x, y, z] = f();
    std::cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z &lt;&lt; std::endl;
    return 0;
}
</code></pre>
</li>
<li>
<p>Template 變動長度參數展開式：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
template&lt;typename ... T&gt;
auto sum(T ... t) {
    return (t + ...);
}
int main() {
    std::cout &lt;&lt; sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
<p>C++20：</p>
<ul>
<li>
<p><code>auto</code> 可以用於 function signature：</p>
<pre><code class="language-cpp">int add(auto x, auto y) {
    return x+y;
}

auto i = 5; // infered as int
auto j = 6; // infered as int
std::cout &lt;&lt; add(i, j) &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
<h2 id="lambda-function"><a class="header" href="#lambda-function">Lambda Function</a></h2>
<p>Lambda function 指的是為了當下某個特定目的建立的匿名 function，作用通常不是為了減少重複程式碼，而是為了將某種程序做為參數傳遞出去。</p>
<p>語法：</p>
<pre><code>[capture list] (parameter list) mutable(optional) exception attribute -&gt; return type {
// function body
}
</code></pre>
<p>其中 <code>[capture list]</code> 代表從 lambda function 外部帶入的變數，注意該變數是在建立 lambda function 的當下就會複製，而不是在呼叫時被複製。</p>
<p>下面是一個 lambda function 的範例，注意建立 lambda function 的當下 <code>value</code> 的數值被 function 給捕獲並且複製一份。 因此就算後續 <code>value</code> 被改成 <code>100</code> 也不會造成影響。</p>
<pre><code class="language-cpp">void lambda_value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout &lt;&lt; "stored_value = " &lt;&lt; stored_value &lt;&lt; std::endl;
    // At this moment, stored_value == 1, and value == 100.
    // Because copy_value has copied when its was created.
}
</code></pre>
<p>Capture list 的格式如下：</p>
<ul>
<li><code>[]</code> 空清單</li>
<li><code>[name1, name2, ...]</code> 最常見，捕獲一系列變數</li>
<li><code>[&amp;]</code> 捕獲外部參考（copy by reference），讓編譯器自行推斷要捕獲誰</li>
<li><code>[=]</code> 捕獲外部值（copy by value），讓編譯器自行推斷要捕獲誰</li>
</ul>
<p>C++14 加入可以在 capture list 中寫 expression 的能力：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;  // std::make_unique
#include &lt;utility&gt; // std::move

void lambda_expression_capture() {
    auto important = std::make_unique&lt;int&gt;(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -&gt; int {
        return x+y+v1+(*v2);
    };
    std::cout &lt;&lt; add(3,4) &lt;&lt; std::endl;
}
</code></pre>
<p>C++14 開始可以在 lambda 使用 <code>auto</code> ：</p>
<pre><code class="language-cpp">auto add = [](auto x, auto y) {
    return x+y;
};

add(1, 2);
add(1.1, 2.2);
</code></pre>
<p>C++11 加入 <code>std::function</code>，正式明確定義 function 為一種型別：</p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

int foo(int para) {
    return para;
}

int main() {
    // std::function wraps a function that take int paremeter and returns int value
    std::function&lt;int(int)&gt; func = foo;

    int important = 10;
    std::function&lt;int(int)&gt; func2 = [&amp;](int value) -&gt; int {
        return 1+value+important;
    };
    std::cout &lt;&lt; func(10) &lt;&lt; std::endl;
    std::cout &lt;&lt; func2(10) &lt;&lt; std::endl;
}
</code></pre>
<p>另外也加入了 <code>std::bind</code> 與 <code>std::placeholder</code>，用以延後傳遞參數的時機：</p>
<pre><code class="language-cpp">int foo(int a, int b, int c) {
    ;
}
int main() {
    // bind parameter 1, 2 on function foo,
    // and use std::placeholders::_1 as placeholder for the first parameter.
    auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2);
    // when call bindFoo, we only need one param left
    bindFoo(1);
}
</code></pre>
<h2 id="stdmove"><a class="header" href="#stdmove"><code>std::move</code></a></h2>
<p>C++11 加入了右值參考 <code>T &amp;&amp;</code> 的概念，用途是可以將一個即將被銷毀的數值轉移到另一個變數。</p>
<p><code>std::move</code> 提供了將一個左值轉換為右值參考的能力，一旦在 expression 中的右側出現了右值參考，C++ 便不會呼叫 copy constructor，而是改呼叫 move constructor (編譯器預設會實作一個)。</p>
<p>Move constructor 的概念是盡可能地只複製 pointer，而不是整份資料，並同時將舊物件內的 pointer 清除（改成 <code>nullptr</code> ），以避免大量資料被複製的行為發生，這也是 <code>std::move</code> 最常見的用途。</p>
<p>考慮以下例子：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
swap(T&amp; a, T&amp; b) {
    T tmp(a);   // we've made a second copy of a
    a = b;      // we've made a second copy of b (and discarded a copy of a)
    b = tmp;    // we've made a second copy of tmp (and discarded a copy of b)
}
</code></pre>
<p>在這個例子中，發生了三次資料複製。</p>
<p>我們可以使用 <code>std::move</code> 改寫來避免複製資料：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
swap(T&amp; a, T&amp; b) {
    T tmp(std::move(a));
    a = std::move(b);   
    b = std::move(tmp);
}
</code></pre>
<p>如果 <code>T</code> 是一個資料結構，例如 <code>vector&lt;int&gt;</code> ，那裡面可能就包含大量資料，用第一版就會浪費大量的資源與時間。</p>
<p>如同 copy constructor，預設 compiler 會幫每一個型別實作一個 move constructor，作法基本上跟 copy constructor 差不多。只差在他不會複製指標指向的資料，而是單純將指標複製一份（做 shallow copy 而非 deep copy）。同時也會修改原本 class 的 member，把所有變數都清空（避免跟 moved 後的物件使用到相同的記憶體空間）。</p>
<h2 id="新增的-containers"><a class="header" href="#新增的-containers">新增的 Containers</a></h2>
<ul>
<li>
<p><code>std::array</code></p>
<ul>
<li>威力加強版的 array，提供了一些 container 的額外功能：</li>
</ul>
<pre><code class="language-cpp">std::array&lt;int, 4&gt; arr = {1, 2, 3, 4};

arr.empty(); // check if container is empty
arr.size();  // return the size of the container

// iterator support
for (auto &amp;i : arr)
{
    // ...
}

// use lambda expression for sort
std::sort(arr.begin(), arr.end(), [](int a, int b) {
    return b &lt; a;
});

// illegal, different than C-style array, std::array will not deduce to T*
// int *arr_p = arr;
</code></pre>
</li>
<li>
<p><code>std::forward_list</code></p>
<ul>
<li>只有單向的 linked list</li>
</ul>
</li>
<li>
<p><code>unordered_set</code> / <code>unordered_map</code> 跟其他東西</p>
<ul>
<li>Hash map 基底的實作，提供 O(1) 插入與查找</li>
</ul>
</li>
<li>
<p><code>std::tuple</code></p>
<ul>
<li><code>std::pair</code> 威力加強版，允許任意數量的組合</li>
<li>常用 function
<ul>
<li><code>std::get</code>: Get the value of a position in the tuple</li>
<li><code>std::tie</code>: tuple unpacking</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
 
std::tuple&lt;double, char, std::string&gt; get_student(int id)
{
    switch (id)
    {
        case 0: return {3.8, 'A', "Lisa Simpson"};
        case 1: return {2.9, 'C', "Milhouse Van Houten"};
        case 2: return {1.7, 'D', "Ralph Wiggum"};
        case 3: return {0.6, 'F', "Bart Simpson"};
    }
 
    throw std::invalid_argument("id");
}
 
int main()
{
    const auto student0 = get_student(0);
    std::cout &lt;&lt; "ID: 0, "
              &lt;&lt; "GPA: " &lt;&lt; std::get&lt;0&gt;(student0) &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; std::get&lt;1&gt;(student0) &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; std::get&lt;2&gt;(student0) &lt;&lt; '\n';
 
    const auto student1 = get_student(1);
    std::cout &lt;&lt; "ID: 1, "
              &lt;&lt; "GPA: " &lt;&lt; std::get&lt;double&gt;(student1) &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; std::get&lt;char&gt;(student1) &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; std::get&lt;std::string&gt;(student1) &lt;&lt; '\n';
 
    double gpa2;
    char grade2;
    std::string name2;
    std::tie(gpa2, grade2, name2) = get_student(2);
    std::cout &lt;&lt; "ID: 2, "
              &lt;&lt; "GPA: " &lt;&lt; gpa2 &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; grade2 &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; name2 &lt;&lt; '\n';
 
    // C++17 structured binding:
    const auto [gpa3, grade3, name3] = get_student(3);
    std::cout &lt;&lt; "ID: 3, "
              &lt;&lt; "GPA: " &lt;&lt; gpa3 &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; grade3 &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; name3 &lt;&lt; '\n';
}
</code></pre>
</li>
</ul>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h2>
<p>Smart pointer 的加入大幅改進了 C++ 管理記憶體的彈性。以往 C++ 開發者如果沒有正確使用 pointer，則可能會造成該 pointer 指向非法空間 (segmentation fault) 或者 memory leak 等常見問題。如果 C++ 開發者使用 smart pointer，C++ 就能夠自動進行記憶體管理，並在適當的時機釋放該釋放的記憶體。</p>
<ul>
<li>
<p><code>std::shared_ptr</code> : 使用計數器管理記憶體的 pointer。</p>
<ul>
<li>原理：每次複製 pointer 時都會造成內部的計數器加一，pointer 被銷毀時計數器減一，當計數器歸零時（即所有的 pointer 都被銷毀時），就會自動釋放背後物件的記憶體空間。
<pre><code class="language-cpp">auto pointer = std::make_shared&lt;int&gt;(10);
auto pointer2 = pointer; // reference count+1
auto pointer3 = pointer; // reference count+1
int *p = pointer.get();  // no increase of reference count

std::cout &lt;&lt; "pointer.use_count() = " &lt;&lt; pointer.use_count() &lt;&lt; std::endl;   // 3
std::cout &lt;&lt; "pointer2.use_count() = " &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 3
std::cout &lt;&lt; "pointer3.use_count() = " &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 3

pointer2.reset();
std::cout &lt;&lt; "reset pointer2:" &lt;&lt; std::endl;

std::cout &lt;&lt; "pointer.use_count() = " &lt;&lt; pointer.use_count() &lt;&lt; std::endl;   // 2
std::cout &lt;&lt; "pointer2.use_count() = " 
    &lt;&lt; pointer2.use_count() &lt;&lt; std::endl;                // pointer2 has reset, 0
std::cout &lt;&lt; "pointer3.use_count() = " &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 2
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>std::unique_ptr</code> : 不能被複製只能 move 的 pointer。</p>
<ul>
<li>
<p>原理：當每次進行 pointer assignment 的行為時，被限定只能用 move 而不能複製的 pointer。舊的 pointer 在 move 完後會當即失效，無法繼續使用。而當這個唯一的 pointer 被銷毀時，背後物件的記憶體也會跟著被釋放。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; // std::cout
#include &lt;memory&gt;

int main()
{
  auto pointer = std::make_unique&lt;int&gt;(10);  // make_unique, from C++14
  // auto pointer2 = pointer;                // copy is illegal
  auto pointer3 = std::move(pointer);        // move is OK
  std::cout &lt;&lt; pointer &lt;&lt; std::endl;
  std::cout &lt;&lt; pointer3 &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>std::weak_ptr</code> : 弱指針，針對 <code>shared_ptr</code> 設計，建立時不會引起計數器加一。</p>
<ul>
<li>
<p><code>shared_ptr</code> 有個常見的問題是，如果有兩個 <code>shared_ptr</code> 互相指向對方，那麼就會造成計數器永遠不會變成 0：</p>
<p><img src="weak-pointer.png" alt="Cycle Share" /></p>
<ul>
<li>因此這時通常會讓其中一個 pointer 改成用 <code>weak_ptr</code>，這樣就 <code>shared_ptr</code> 就可以正常歸零。</li>
</ul>
</li>
<li>
<p>用法：直接 assign <code>shared_ptr</code> 給 <code>weak_ptr</code> 即可</p>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; a = std::make_shared&lt;int&gt;(42);
std::weak_ptr&lt;int&gt; b = a;
</code></pre>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="cpp_advanced.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="cpp_concurrency.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="cpp_advanced.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="cpp_concurrency.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
