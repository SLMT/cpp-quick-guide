<!DOCTYPE HTML>
<html lang="zh-TW" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>小山的 C++ 快速上手筆記</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">簡介</a></li><li class="chapter-item expanded "><a href="cpp_basics.html"><strong aria-hidden="true">1.</strong> C++ 基礎知識加強</a></li><li class="chapter-item expanded "><a href="cpp_stl.html"><strong aria-hidden="true">2.</strong> C++ STL</a></li><li class="chapter-item expanded "><a href="cpp_oop.html"><strong aria-hidden="true">3.</strong> C++ 物件導向</a></li><li class="chapter-item expanded "><a href="cpp_advanced.html"><strong aria-hidden="true">4.</strong> C++ 進階語法</a></li><li class="chapter-item expanded "><a href="modern_cpp.html"><strong aria-hidden="true">5.</strong> Modern C++ (C++11 之後的變化)</a></li><li class="chapter-item expanded "><a href="cpp_concurrency.html"><strong aria-hidden="true">6.</strong> C++ Concurrency</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">小山的 C++ 快速上手筆記</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="小山的-c-快速上手筆記"><a class="header" href="#小山的-c-快速上手筆記">小山的 C++ 快速上手筆記</a></h1>
<p><a href="https://github.com/SLMT/cpp-quick-guide/actions/workflows/deploy.yml"><img src="https://github.com/SLMT/cpp-quick-guide/actions/workflows/deploy.yml/badge.svg" alt="Deploy" /></a></p>
<p>本書是為了讓不熟悉 C++ 的人，在有接觸過其他 OOP 程式語言（例如 Java）的前提下快速上手所做的筆記。</p>
<ul>
<li>本書網址： <a href="https://www.slmt.tw/cpp-quick-guide/">https://www.slmt.tw/cpp-quick-guide/</a></li>
<li>本書 Repository： <a href="https://github.com/SLMT/cpp-quick-guide">https://github.com/SLMT/cpp-quick-guide</a></li>
</ul>
<h2 id="先備知識"><a class="header" href="#先備知識">先備知識</a></h2>
<p>預期閱讀此筆記前，假定讀者已經：</p>
<ul>
<li>學習過 C 語言（或類似語法的語言）</li>
<li>熟悉其他物件導向 (OOP) 程式語言 (e.g., Java, JavaScript, Golang...)</li>
</ul>
<h2 id="內容哪裡來的"><a class="header" href="#內容哪裡來的">內容哪裡來的？</a></h2>
<p>這本筆記的內容主要是我從以下網站中整理出來的重點回顧：</p>
<ul>
<li>TutorialsPoint C++： <a href="https://www.tutorialspoint.com/cplusplus/index.htm">https://www.tutorialspoint.com/cplusplus/index.htm</a></li>
<li>Microsoft Learn - C++ 文件： <a href="https://learn.microsoft.com/zh-tw/cpp/cpp/?view=msvc-170">https://learn.microsoft.com/zh-tw/cpp/cpp/?view=msvc-170</a></li>
<li>GeeksforGeeks - The C++ Standard Template Library (STL)： <a href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/">https://www.geeksforgeeks.org/the-c-standard-template-library-stl/</a></li>
<li>Modern C++ Tutorial: C++ 11/14/17/20 On the Fly： <a href="https://changkun.de/modern-cpp/en-us/00-preface/">https://changkun.de/modern-cpp/en-us/00-preface/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-基礎知識加強"><a class="header" href="#c-基礎知識加強">C++ 基礎知識加強</a></h1>
<p>加強一些 C++ 與其他語言不同之處。</p>
<h2 id="特別資料型別"><a class="header" href="#特別資料型別">特別資料型別</a></h2>
<ul>
<li><code>bool</code> : boolean 型別</li>
<li><code>wchar_t</code> : wide characters (16 bits) 字元，用來補足原本的 <code>char</code> 型別大小不足的問題，以支援 Unicode</li>
<li>固定大小整數型別，避免了傳統 C 語言的 <code>int</code> 等型別大小不固定的問題，例如：
<ul>
<li><code>int64_t</code>: 64-bit 整數</li>
<li><code>uint32_t</code>: 32-bit 無號整數</li>
<li>完整清單： <a href="https://en.cppreference.com/w/cpp/types/integer">https://en.cppreference.com/w/cpp/types/integer</a></li>
</ul>
</li>
</ul>
<h2 id="取得型別的-max--min"><a class="header" href="#取得型別的-max--min">取得型別的 Max &amp; Min</a></h2>
<ul>
<li>方法一: 使用內建常數
<ul>
<li><code>INT32_MAX</code> (需要引入 <code>stdint.h</code>)</li>
</ul>
</li>
<li>方法二:  <code>std::numeric_limits&lt;T&gt;::min()</code>
<ul>
<li><code>T</code> 可以換成任意內建型別</li>
</ul>
</li>
</ul>
<h2 id="變數宣告修飾子"><a class="header" href="#變數宣告修飾子">變數宣告修飾子</a></h2>
<ul>
<li>Storage Class
<ul>
<li><code>auto</code> : 跟代表自動推導的 <code>auto</code> 不同，限制變數只能被宣告的 scope 內的程式碼存取，預設情況下 local variable 前都會自動加上 <code>auto</code>
<ul>
<li>Example： <code>auto int a = 1</code></li>
</ul>
</li>
<li><code>register</code> : 提示 compiler 將變數存在 CPU register (C++11 之後 deprecated)</li>
<li><code>static</code> :
<ul>
<li>用在 local variable 會讓這個 local variable 的值與記憶體空間一直保留到程式結束</li>
<li>用在 global variable 會限制該 variable 的 scope 在所在的 file 中</li>
<li>用在 class member 會讓該 member shared 在所有 object 中</li>
</ul>
</li>
<li><code>extern</code> : 代表變數定義在其他檔案內，linking 時才會引入
<ul>
<li>Example: <code>extern int num</code></li>
<li>說明：<a href="https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170">https://learn.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170</a></li>
</ul>
</li>
<li><code>mutable</code> : 只能用在 class member 上，當物件的變數被指定為 <code>const</code> 時，該 class member 仍能夠被外界修改。</li>
</ul>
</li>
<li>全域變數宣告時會自動初始化為 <code>NULL</code> / <code>0</code></li>
</ul>
<h2 id="type-qualifiers"><a class="header" href="#type-qualifiers">Type Qualifiers</a></h2>
<ul>
<li><code>const</code> : 常數</li>
<li><code>volatile</code> : 防止存取此變數的動作因為 compiler optimization 的關係被調換位置
<ul>
<li>同時也限制 CPU 不能快取此變數在 CPU cache (multi-threading 時很重要)</li>
</ul>
</li>
<li><code>restrict</code> : 限制只有此指標變數可以指向該記憶體位置
<ul>
<li>屬於 C99 標準，非 C++ 標準</li>
<li><a href="https://wucodingroad.blogspot.com/2017/05/Cplusplus-restrict.html">https://wucodingroad.blogspot.com/2017/05/Cplusplus-restrict.html</a></li>
</ul>
</li>
</ul>
<h2 id="reference-參考"><a class="header" href="#reference-參考">Reference (參考)</a></h2>
<p>Reference 是 C++ 引入給變數設定「別名」的功能，跟 pointer 關鍵差異如下：</p>
<ul>
<li>Null 值：Pointer 允許 <code>NULL</code>，reference 不行</li>
<li>修改指向位置：Pointer 的變數可以途中修改成指向其他記憶體位置，reference 不行</li>
<li>初始化：Reference 初始化時一定要設定指向的變數，pointer 沒有限制</li>
</ul>
<p>宣告方式：</p>
<pre><code class="language-cpp">// declare simple variables
int    i;
double d;

// declare reference variables
int&amp;    r = i;
double&amp; s = d;
</code></pre>
<p>Reference 可以從 function 被 return：</p>
<pre><code class="language-cpp">double&amp; setValues( int i ) {
   return vals[i];   // return a reference to the ith element
}
</code></pre>
<p>但要注意不能 return local variable 的 reference</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<ul>
<li>
<p>宣告方式： <code>double a[10];</code></p>
</li>
<li>
<p>多維陣列： <code>int threedim[5][10][4];</code></p>
</li>
<li>
<p>初始化： <code>double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};</code></p>
</li>
<li>
<p>初始化二維陣列：</p>
<pre><code class="language-cpp">int a[3][4] = {
   {0, 1, 2, 3} ,   /*  initializers for row indexed by 0 */
   {4, 5, 6, 7} ,   /*  initializers for row indexed by 1 */
   {8, 9, 10, 11}   /*  initializers for row indexed by 2 */
};
</code></pre>
</li>
<li>
<p>Array 的變數其實就是 pointer：</p>
<pre><code class="language-cpp">double *p;
double balance[10];

p = balance;
</code></pre>
<ul>
<li><code>balance[4]</code> 等價於 <code>*(balance + 4)</code></li>
</ul>
</li>
<li>
<p>Array 作為 paramater 傳進 function 方法有兩種常見方式：</p>
<ul>
<li>
<p>Method 1: 用 pointer</p>
<pre><code class="language-cpp">void myFunction(int *param) {
   // ...
}
</code></pre>
</li>
<li>
<p>Method 2: 用 unsized array</p>
<pre><code class="language-cpp">void myFunction(int param[]) {
   // ...
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>從 function return array 只有一種做法，就是回傳 pointer：</p>
<pre><code class="language-cpp">int * myFunction() {
   // ...
}
</code></pre>
</li>
</ul>
<h2 id="c-string"><a class="header" href="#c-string">C++ String</a></h2>
<p>C++ 有內建 String 型別，所以可以不使用 C-style string (也就是字元陣列)</p>
<p>使用方式：</p>
<pre><code class="language-cpp">#include &lt;string&gt;
using std::string;

string s = "aabbcc";
s.size(); // return 6
s.find("bb"); // return 2
s += "123"; // s = aabbcc123
</code></pre>
<p>字面值直接使用 string 型別（省掉一個轉換步驟，需要 <code>using namespace std::literals</code>）：</p>
<pre><code class="language-cpp">using namespace std::literals;
string s3_2 = "hello world"s;
</code></pre>
<p>基本操作：</p>
<pre><code class="language-cpp">os &lt;&lt; s // 輸出 s 
is &gt;&gt; s // 輸入 s
s.empty() // 檢查 s 是否為空
s.size() // s 目前長度
s[n] // 直接取得 s 的第 n 個元素
s.at(n) // 同樣取得第 n 個元素，但會檢查邊界
s1 + s2 // 把 s1 加 s2 取得新的字串
s1.append(s2) // 把 s2 加到 s1 後面，不會產生新字串
s1 += s2 // 等價於 s1.append(s2)
s1 = s2 //　拷貝複製 s2
s1 != s2 // 比較 s1 和 s2 是否相同
&lt;, &lt;=, ==, &gt;=, &gt; // 做大小比較，以字典排序
</code></pre>
<p>完整 C++ String 教學： <a href="https://tigercosmos.xyz/post/2023/06/c++/std-string-beginner/">https://tigercosmos.xyz/post/2023/06/c++/std-string-beginner/</a></p>
<h2 id="standard-inputoutput"><a class="header" href="#standard-inputoutput">Standard Input/Output</a></h2>
<p>C++ 有以下幾個常用的 input/output streams</p>
<ul>
<li><code>cin</code> : 標準輸入</li>
<li><code>cout</code> : 標準輸出</li>
<li><code>cerr</code> : 標準錯誤（但沒有 buffer）</li>
<li><code>clog</code> : 標準錯誤（但有 buffer）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-stl"><a class="header" href="#c-stl">C++ STL</a></h1>
<p>Standard Template Library (STL) 是 C++ 之中最重要的函式庫，包含多項重要的元件：</p>
<ul>
<li>Containers： 各種儲存與操作資料的容器</li>
<li>Algorithms： 各種高效的演算法</li>
<li>Iterators： 用來依照某些邏輯存取容器內資料的存取器</li>
<li>Function Objects： 提供將 function 做為參數傳入 function 的方法，可以幫助客製化演算法的行為</li>
<li>Adapters： 可以用來修改 STL 內其他元件行為的工具</li>
</ul>
<h2 id="containers"><a class="header" href="#containers">Containers</a></h2>
<p>STL container 清單： <a href="https://cplusplus.com/reference/stl/">https://cplusplus.com/reference/stl/</a></p>
<p>需要注意的 containers：</p>
<ul>
<li>
<p><code>forward_list</code> ： 只有向前指針的 linked list，比 <code>list</code> (具備前後指針) 使用更少的空間</p>
</li>
<li>
<p><code>priority_queue</code> ：  用 heap 實作的 queue，最大的東西會在最前面</p>
<ul>
<li>
<p>一般用法：</p>
<pre><code class="language-cpp">int arr[6] = { 10, 2, 4, 8, 6, 9 };
priority_queue&lt;int&gt; pq;
 
// pushing array sequentially one by one
for (int i = 0; i &lt; 6; i++) {
    pq.push(arr[i]);
}
 
// printing priority queue
cout &lt;&lt; "Priority Queue: ";
while (!pq.empty()) {
    cout &lt;&lt; pq.top() &lt;&lt; ' ';
    pq.pop();
}
</code></pre>
</li>
<li>
<p>修改成最小在最前面：</p>
<pre><code class="language-cpp">int arr[6] = { 10, 2, 4, 8, 6, 9 };
priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; gquiz(arr, arr + 6);
</code></pre>
</li>
<li>
<p>使用自製的 comparator：</p>
<pre><code class="language-cpp">class Foo { /* data */ };

class Comparator
{
public:
    bool operator() (Foo, Foo)
    {
		// Should the first one be in front of the second one?
        return true;
    }
};

int main()
{
    std::priority_queue&lt;Foo, std::vector&lt;Foo&gt;, Comparator&gt; pq;
    return 0;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>set</code> ： sorted set，用紅黑樹實作</p>
</li>
<li>
<p><code>map</code> ： sorted map，實作與 <code>set</code> 相同</p>
</li>
<li>
<p><code>multiset</code> ： 跟 <code>set</code> 一樣是 sorted set，但可以存重複資料</p>
</li>
<li>
<p><code>multimap</code> ： 跟 <code>map</code> 一樣是 sorted map，但可以存重複的 key</p>
<ul>
<li>注意用 <code>find(key)</code> 只會拿到一個 key-value pair，如果想要抓出所有重複 key 的 pair，要使用 <code>equal_range(key)</code>
<ul>
<li><code>equal_range(key)</code> 回傳的是一個 pair， <code>first</code> 是 iterator 的開頭（lower bound, inclusive）， <code>second</code> 是 iterator 的結尾 (upper bound, exclusive)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h2>
<p>常用 algorithms：</p>
<ul>
<li>
<p><code>sort(begin, end)</code> ： 使用 IntroSort 進行排序</p>
<ul>
<li>
<p>IntroSort：先嘗試使用 quick sort。 如果發現 partition 差太多，改成用 heap sort。 如果 size 夠小，改成用 insertion sort。</p>
</li>
<li>
<p>基本用法：</p>
<pre><code class="language-cpp">int arr[] = {3, 5, 1, 2, 4};
sort(arr, arr + 5);

vector&lt;int&gt; vec {3, 5, 1, 2, 4};
sort(vec.begin(), vec.end());
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>binary_search(begin, end, value)</code> ： 使用 binary search</p>
</li>
<li>
<p><code>reverse(begin, end)</code> ： 反轉順序</p>
</li>
</ul>
<h2 id="iterator"><a class="header" href="#iterator">Iterator</a></h2>
<p>可以看 C++ Reference 官網的介紹，簡單明瞭： <a href="https://cplusplus.com/reference/iterator/">https://cplusplus.com/reference/iterator/</a></p>
<p>只要搞懂 Input, Output, Forward, Bidirectional, Random Access 這五種 iterator 的差異，跟他們的從屬關係就好。</p>
<h2 id="function-objects-functors"><a class="header" href="#function-objects-functors">Function Objects (Functors)</a></h2>
<p>直接看一例子，這個例子是寫一個 class 幫所有 array 所有的 element 加上想要的數字：</p>
<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

// A Functor
class increment
{
private:
	int num;
public:
	increment(int n) : num(n) { }

	// This operator overloading enables calling
	// operator function () on objects of increment
	int operator () (int arr_num) const {
		return num + arr_num;
	}
};

// Driver code
int main()
{
	int arr[] = {1, 2, 3, 4, 5};
	int n = sizeof(arr)/sizeof(arr[0]);
	int to_add = 5;

	transform(arr, arr+n, arr, increment(to_add));

	for (int i=0; i&lt;n; i++)
		cout &lt;&lt; arr[i] &lt;&lt; " ";
}
</code></pre>
<p>主要是提供了改寫 <code>()</code> 行為的能力，所以讓一個 object 可以被像 function 一樣呼叫。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<h3 id="pairs"><a class="header" href="#pairs">Pairs</a></h3>
<p>C++ STL 提供了 pair 可以使用：</p>
<pre><code class="language-cpp">// CPP program to illustrate Pair in STL
#include &lt;iostream&gt;
#include &lt;utility&gt;

using namespace std;

// Driver Code
int main()
{
	// defining a pair
	pair&lt;int, char&gt; PAIR1;

	// first part of the pair
	PAIR1.first = 100;
	// second part of the pair
	PAIR1.second = 'G';

	cout &lt;&lt; PAIR1.first &lt;&lt; " ";
	cout &lt;&lt; PAIR1.second &lt;&lt; endl;

	return 0;
}

</code></pre>
<ul>
<li>Pair 可以被比較，會先比第一個再比第二個</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-物件導向"><a class="header" href="#c-物件導向">C++ 物件導向</a></h1>
<h2 id="class-的宣告與定義"><a class="header" href="#class-的宣告與定義">Class 的宣告與定義</a></h2>
<p>基本例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
 
using namespace std;
 
class Box {
   public:
      double length;
      void setWidth( double wid );
      double getWidth( void );
 
   private:
      double width;
};
 
// Member functions definitions
double Box::getWidth(void) {
   return width ;
}
 
void Box::setWidth( double wid ) {
   width = wid;
}
 
// Main function for the program
int main() {
   Box box;
 
   // set box length without member function
   box.length = 10.0; // OK: because length is public
   cout &lt;&lt; "Length of box : " &lt;&lt; box.length &lt;&lt;endl;
 
   // set box width without member function
   // box.width = 10.0; // Error: because width is private
   box.setWidth(10.0);  // Use member function to set it.
   cout &lt;&lt; "Width of box : " &lt;&lt; box.getWidth() &lt;&lt;endl;
 
   return 0;
}
</code></pre>
<h2 id="initialization-list"><a class="header" href="#initialization-list">Initialization List</a></h2>
<p>在 constructor 上可以加上特殊的 list 初始化 member data，如下：</p>
<pre><code class="language-cpp">C::C(double a, double b, double c): X(a), Y(b), Z(c) {
   ....
}
</code></pre>
<h2 id="copy-constructor"><a class="header" href="#copy-constructor">Copy Constructor</a></h2>
<p>C++ 規定每一個 class 都要有一個 copy constructor 具備可以複製整個物件的能力，形式如下：</p>
<pre><code class="language-cpp">classname (const classname &amp;obj) {
   // body of constructor
}
</code></pre>
<p>如果沒有的話 C++ 會自動創建一個預設的，做法是會呼叫所有 member variable 的 copy constructor 實現 deep copy。</p>
<h2 id="friend-functions--classes"><a class="header" href="#friend-functions--classes">Friend Functions &amp; Classes</a></h2>
<p>Class 內可以定義 friend function 與 class 如下：</p>
<pre><code class="language-cpp">class Box {
   double width;
   
   public:
      double length;

      friend void printWidth( Box box );
      void setWidth( double wid );

      friend class ClassTwo;
};
</code></pre>
<p>這樣寫代表外面的 <code>printWidth</code> 與 <code>ClassTwo</code> 就可以直接存取 Box 的 private variable <code>width</code></p>
<h2 id="static-members"><a class="header" href="#static-members">Static Members</a></h2>
<p>C++ 的 class 可以定義 static member，但變數的初始化必須要寫在 class definition 外面：</p>
<pre><code class="language-cpp">// foo.h
class foo
{
    private:
        static int i;
};

// foo.cpp
int foo::i = 0;
</code></pre>
<p>其他特性基本跟 Java 的 static 相同。</p>
<h2 id="繼承性"><a class="header" href="#繼承性">繼承性</a></h2>
<p>與 Java 的關鍵差異：</p>
<ul>
<li>可以繼承多個 class
<ul>
<li>這點比較像是 Java 的 interface</li>
</ul>
</li>
<li>繼承時可以設定 access modifier
<ul>
<li>
<p>例如下面的例子將 base class 設定為 public</p>
<pre><code class="language-cpp">// Base class
class Shape {
   // ...
};

// Derived class
class Rectangle: public Shape {
   // ...
};
</code></pre>
</li>
<li>
<p>這個用途是可以修改原本 base class 內的 member 存取性質，但只能改得更嚴格，不能放得更鬆</p>
<ul>
<li>設定為 public ⇒ 不修改 base class 的 member</li>
<li>設定為 protected ⇒ 原本是 public 的 member 都會變成 protected</li>
<li>設定為 private ⇒ 原本是 public 與 protected 的 member 會變成 private</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="operators-overloading"><a class="header" href="#operators-overloading"><strong>Operators Overloading</strong></a></h2>
<p>C++ 的一大特色就是可以修改 operator 對 class 造成的效果</p>
<p>假設有一個 <code>Box</code> class，希望將 <code>+</code> 的效果改成分別把長寬高相加，那要這樣修改：</p>
<pre><code class="language-cpp">class Box {
   public:
      // ...
      
      // Overload + operator to add two Box objects.
      Box operator+(const Box&amp; b) {
         Box box;
         box.length = this-&gt;length + b.length;
         box.breadth = this-&gt;breadth + b.breadth;
         box.height = this-&gt;height + b.height;
         return box;
   // ...
}
</code></pre>
<h2 id="function-override--virtual-functions"><a class="header" href="#function-override--virtual-functions">Function Override &amp; Virtual Functions</a></h2>
<p>在 C++ 中，如果衍伸類別要改寫基底類別的 method，基底類別就必須要將 method 定義為 virtual：</p>
<pre><code class="language-cpp">class Shape {
   protected:
      int width, height;

   public:
      Shape( int a = 0, int b = 0){
         width = a;
         height = b;
      }
      virtual int area() {
         cout &lt;&lt; "Parent class area :" &lt;&lt; width * height &lt;&lt; endl;
         return width * height;
      }
};

class Triangle: public Shape {
   public:
      Triangle( int a = 0, int b = 0):Shape(a, b) { }

      int area () {
         cout &lt;&lt; "Triangle class area :" &lt;&lt; (width * height)/2 &lt;&lt; endl;
         return (width * height / 2);
      }
};
</code></pre>
<p>這是因為 C++ 在 class 建立時，預設會用 static linkage 綁定 function 的定義，而這個會導致當一個 function 被呼叫時，「只會根據其 variable type 來判斷該呼叫哪一個 function」。也就是說，無論實際上物件是 <code>Shape</code> 還是 <code>Triangle</code> ，只要他是 <code>Shape</code> 的變數，就會呼叫到 <code>Shape</code> 的 <code>area()</code> 。</p>
<p>如果將 function 設定為 virtual，C++ 就會知道該將 function 改用 dynamic linkage 處理，他會根據當下 object 的實際類別來判斷該呼叫哪一個 function (使用 vtable)。</p>
<p>簡單的比較例子：</p>
<pre><code class="language-cpp">class Base
{
  public:
            void Method1 ()  {  std::cout &lt;&lt; "Base::Method1" &lt;&lt; std::endl;  }
    virtual void Method2 ()  {  std::cout &lt;&lt; "Base::Method2" &lt;&lt; std::endl;  }
};

class Derived : public Base
{
  public:
    void Method1 ()          {  std::cout &lt;&lt; "Derived::Method1" &lt;&lt; std::endl;  }
    void Method2 () override {  std::cout &lt;&lt; "Derived::Method2" &lt;&lt; std::endl;  }
    // Note - override is optional; adding it to Method1 would result in an error
};

Base* basePtr = new Derived ();
// Note - constructed as Derived, but pointer stored as Base*

basePtr-&gt;Method1 ();  //  Prints "Base::Method1"
basePtr-&gt;Method2 ();  //  Prints "Derived::Method2"
</code></pre>
<p>參考資料： <a href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c">https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c</a></p>
<h2 id="abstract-methods--abstract-class"><a class="header" href="#abstract-methods--abstract-class">Abstract Methods &amp; Abstract Class</a></h2>
<p>C++ 並沒有 <code>abstract</code> 關鍵字，但是可以用別的方式做到相同效果。</p>
<p>只要單純宣告但不定義 virtual function，並且加上 <code>= 0</code> ，就稱之為 pure virtual function：</p>
<pre><code class="language-cpp">virtual int area() = 0;
</code></pre>
<p>這等同於 Java 的 abstract method。</p>
<p>只要 class 中包含至少一個 pure virtual function，那麼該 class 就不能被實體化，因此效果等同於 abstract class。</p>
<h2 id="class-vs-struct"><a class="header" href="#class-vs-struct">Class vs. Struct</a></h2>
<p>C++ 的 class 與 struct 其實沒有太大的差別，只是有幾個關鍵差異：</p>
<ul>
<li>Class 的 member 預設是 private，struct 是 public
<ul>
<li>繼承的時候也類似，class 預設會是 private 繼承</li>
</ul>
</li>
<li>Class 可以當作 template 的關鍵字用，struct 不行</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-進階語法"><a class="header" href="#c-進階語法">C++ 進階語法</a></h1>
<h2 id="try-catch"><a class="header" href="#try-catch">Try-Catch</a></h2>
<p>C++ 可以 throw exception，而且可以用 try-catch 抓住。與 Java 最大的不同在於 C++ 的 throw 可以丟出任何種類的資料，catch 只要寫清楚資料的型別就好：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

double division(int a, int b) {
   if( b == 0 ) {
      throw "Division by zero condition!";
   }
   return (a/b);
}

int main () {
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
      z = division(x, y);
      cout &lt;&lt; z &lt;&lt; endl;
   } catch (const char* msg) {
     cerr &lt;&lt; msg &lt;&lt; endl;
   }

   return 0;
}
</code></pre>
<p>C++ STD 有內建一系列的 exception，可以在下面網頁看到清單：</p>
<p><a href="https://cplusplus.com/reference/exception/exception/?kw=exception">https://cplusplus.com/reference/exception/exception/?kw=exception</a></p>
<p>另外官方也鼓勵開發者繼承 <code>exception</code> class 來製造自己的錯誤種類，其中只需要 override <code>what()</code> (顯示錯誤資訊的 function) 就好。</p>
<h2 id="template"><a class="header" href="#template">Template</a></h2>
<p>Template 就是 Jave 的 generic，只是語法稍微不同，功能也沒那麼強而已。</p>
<p>定義 function template 的範例如下：</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T minimum(const T&amp; lhs, const T&amp; rhs)
{
    return lhs &lt; rhs ? lhs : rhs;
}
</code></pre>
<p>定義 class template 的範例如下：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
class Stack { 
   private: 
      vector&lt;T&gt; elems;    // elements 

   public: 
      void push(T const&amp;);  // push element 
      void pop();               // pop element 
      T top() const;            // return top element 
      
      bool empty() const {      // return true if empty.
         return elems.empty(); 
      } 
}; 

template &lt;class T&gt;
void Stack&lt;T&gt;::push (T const&amp; elem) { 
   // append copy of passed element 
   elems.push_back(elem);    
} 
</code></pre>
<p>注意當 class method 的定義沒有寫在 class 的宣告內時，也要額外宣告 <code>template &lt;class T&gt;</code> 的標籤。</p>
<p>MSFT 官網有針對 template 更加詳盡的介紹： <a href="https://learn.microsoft.com/zh-tw/cpp/cpp/templates-cpp?view=msvc-170">https://learn.microsoft.com/zh-tw/cpp/cpp/templates-cpp?view=msvc-170</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modern-c-c11-之後的變化"><a class="header" href="#modern-c-c11-之後的變化">Modern C++ (C++11 之後的變化)</a></h1>
<h2 id="棄用語法"><a class="header" href="#棄用語法">棄用語法</a></h2>
<ul>
<li>字串 literal 應該改用 <code>const char *</code> 型別而不是 <code>char *</code> 型別宣告</li>
<li><code>register</code> 的效果被移除（不再具有將變數放入 CPU register 的效果）</li>
<li><code>bool</code> 不可以 <code>++</code></li>
<li>C 語言風格的轉換方式 <code>(type)</code> 被棄用，應該改用 <code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code> 等方式轉換</li>
</ul>
<h2 id="新增語法"><a class="header" href="#新增語法">新增語法</a></h2>
<p>C++11：</p>
<ul>
<li>
<p>指定 Null Pointer 應改用 <code>nullptr</code> 而不是 <code>NULL</code></p>
<ul>
<li><code>NULL</code> 可能會被解析成 <code>int</code> 造成額外問題，例如有兩個 function 分別為 <code>foo(int a)</code> 與 <code>foo(char* b)</code>，當我們呼叫 <code>foo(NULL)</code> 就不見得會呼叫 <code>foo(char* b)</code> 那個。</li>
</ul>
</li>
<li>
<p>加入 <code>constexpr</code>：用來表示某一個 expression 或 function 輸出的結果是一個常數</p>
<ul>
<li>
<p>編譯器會去驗證這點，並且可以以此來優化程式碼</p>
</li>
<li>
<p>範例：</p>
<pre><code class="language-cpp">constexpr int fibonacci(const int n) {
    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);
}
</code></pre>
<pre><code class="language-cpp">constexpr int var_constexpr = 1 + 2 + 3;
</code></pre>
</li>
</ul>
</li>
<li>
<p>提供可以使用 initialization list 初始化任意物件的能力（但需要實作對應的 constructor）</p>
<ul>
<li>範例：
<pre><code class="language-cpp">#include &lt;initializer_list&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

class MagicFoo {
public:
    std::vector&lt;int&gt; vec;
    MagicFoo(std::initializer_list&lt;int&gt; list) {
        for (std::initializer_list&lt;int&gt;::iterator it = list.begin();
            it != list.end(); ++it)
            vec.push_back(*it);
    }
};
int main() {
    // after C++11
    MagicFoo magicFoo = {1, 2, 3, 4, 5};

    std::cout &lt;&lt; "magicFoo: ";
    for (std::vector&lt;int&gt;::iterator it = magicFoo.vec.begin(); 
        it != magicFoo.vec.end(); ++it) 
        std::cout &lt;&lt; *it &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加入 <code>auto</code> ：自動型別推導</p>
<pre><code class="language-cpp">auto i = 5;              // i is inferred as int
auto arr = new auto(10); // arr is inferred as int *
</code></pre>
<ul>
<li>
<p><code>auto</code> 也常用於 template 指定 function return type 時，這樣就不需要額外定義另一個 type 變數：</p>
<pre><code class="language-cpp">// Old way
template&lt;typename R, typename T, typename U&gt;
R add(T x, U y) {
    return x + y;
}

// After C++11
template&lt;typename T, typename U&gt;
auto add(T x, U y){
    return x + y;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>加入 <code>decltype</code> ： 輸出變數是何種型別</p>
<ul>
<li>
<p>通常搭配 <code>std::is_same&lt;T, U&gt;</code> 使用，檢查是否兩個型別是同一個型別</p>
<pre><code class="language-cpp">auto x = 1;
if (std::is_same&lt;decltype(x), int&gt;::value)
    std::cout &lt;&lt; "type x == int" &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
</li>
<li>
<p>Ranged for loop</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; vec = {1, 2, 3, 4};
for (auto element : vec)
    std::cout &lt;&lt; element &lt;&lt; std::endl; // read only
for (auto &amp;element : vec) {
    element += 1;                      // writeable
}
</code></pre>
<ul>
<li>宣告 ranged for loop 變數的原則：
<ul>
<li>想 copy 數值 =&gt; 使用 <code>auto x</code></li>
<li>想直接引用原本的物件，並且可能會修改 =&gt; 使用 <code>auto &amp;x</code></li>
<li>想直接引用原本的物件，但不會修改 =&gt; 使用 <code>auto const &amp;x</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>搭配 <code>template</code> 使用別名：</p>
<pre><code class="language-cpp">template&lt;typename T, typename U&gt;
class MagicType {
public:
    T dark;
    U magic;
};

template&lt;typename T&gt;
using TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;

int main() {
    TrueDarkMagic&lt;bool&gt; you;
}
</code></pre>
</li>
<li>
<p>Template 變動變數清單：</p>
<pre><code class="language-cpp">template&lt;typename... Ts&gt;
void magic(Ts... args) {
    std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl;
}

magic(); // Print: 0
magic(1); // Print: 1
magic(1, ""); // Print: 2
</code></pre>
</li>
<li>
<p>Delegate constructor：允許重複使用同一個 class 內的 constructor</p>
<pre><code class="language-cpp">class Base {
public:
    int value1;
    int value2;
    Base() {
        value1 = 1;
    }
    Base(int value) : Base() { // delegate Base() constructor
        value2 = value;
    }
};
</code></pre>
</li>
<li>
<p>繼承 constructor：使用 <code>using</code> 關鍵字來使用 base class 的 constructor</p>
<pre><code class="language-cpp">class Subclass : public Base {
public:
    using Base::Base; // inheritance constructor
};
</code></pre>
</li>
<li>
<p>加入 <code>override</code> : 強制檢查是否複寫不存在的 virtual function</p>
<pre><code class="language-cpp">struct Base {
    virtual void foo(int);
};
struct SubClass: Base {
    virtual void foo(int) override; // legal
    virtual void foo(float) override; // illegal, no such virtual function
};
</code></pre>
</li>
<li>
<p>加入 <code>final</code> : 阻止繼承或 override</p>
<pre><code class="language-cpp">struct Base {
    virtual void foo() final;
};
struct SubClass1 final: Base {
}; // legal

struct SubClass2 : SubClass1 {
}; // illegal, SubClass1 has final

struct SubClass3: Base {
    void foo(); // illegal, foo has final
};
</code></pre>
</li>
<li>
<p>拒絕或明確要求預設實作（用於 constructor 或 operator 等等）：</p>
<pre><code class="language-cpp">class Magic {
    public:
    Magic() = default; // explicit let compiler use default constructor
    Magic&amp; operator=(const Magic&amp;) = delete; // explicit declare refuse constructor
    Magic(int magic_number);
}
</code></pre>
</li>
<li>
<p><code>enum class</code></p>
<ul>
<li>與 <code>enum</code> 不同處在於：
<ul>
<li>不會預設可以轉換為 int</li>
<li>多個 <code>enum class</code> 存在相同名稱的 variant 也不會產生名稱衝突</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">enum class new_enum : unsigned int {
    value1,
    value2,
    value3 = 100,
    value4 = 100
};
</code></pre>
</li>
</ul>
<p>C++17：</p>
<ul>
<li>
<p>可以在 if 條件式宣告變數</p>
<pre><code class="language-cpp">if (const auto itr = std::find(vec.begin(), vec.end(), 3);
    itr != vec.end()) {
    *itr = 4;
}
</code></pre>
</li>
<li>
<p>可以對 if statement 使用 <code>constexpr</code></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

template&lt;typename T&gt;
auto print_type_info(const T&amp; t) {
    if constexpr (std::is_integral&lt;T&gt;::value) {
        return t + 1;
    } else {
        return t + 0.001;
    }
}
int main() {
    std::cout &lt;&lt; print_type_info(5) &lt;&lt; std::endl;
    std::cout &lt;&lt; print_type_info(3.14) &lt;&lt; std::endl;
}
</code></pre>
</li>
<li>
<p>宣告變數時可以解構資料，例如下面的 <code>[x, y, z]</code>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;tuple&gt;

std::tuple&lt;int, double, std::string&gt; f() {
    return std::make_tuple(1, 2.3, "456");
}

int main() {
    auto [x, y, z] = f();
    std::cout &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ", " &lt;&lt; z &lt;&lt; std::endl;
    return 0;
}
</code></pre>
</li>
<li>
<p>Template 變動長度參數展開式：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
template&lt;typename ... T&gt;
auto sum(T ... t) {
    return (t + ...);
}
int main() {
    std::cout &lt;&lt; sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
<p>C++20：</p>
<ul>
<li>
<p><code>auto</code> 可以用於 function signature：</p>
<pre><code class="language-cpp">int add(auto x, auto y) {
    return x+y;
}

auto i = 5; // infered as int
auto j = 6; // infered as int
std::cout &lt;&lt; add(i, j) &lt;&lt; std::endl;
</code></pre>
</li>
</ul>
<h2 id="lambda-function"><a class="header" href="#lambda-function">Lambda Function</a></h2>
<p>Lambda function 指的是為了當下某個特定目的建立的匿名 function，作用通常不是為了減少重複程式碼，而是為了將某種程序做為參數傳遞出去。</p>
<p>語法：</p>
<pre><code>[capture list] (parameter list) mutable(optional) exception attribute -&gt; return type {
// function body
}
</code></pre>
<p>其中 <code>[capture list]</code> 代表從 lambda function 外部帶入的變數，注意該變數是在建立 lambda function 的當下就會複製，而不是在呼叫時被複製。</p>
<p>下面是一個 lambda function 的範例，注意建立 lambda function 的當下 <code>value</code> 的數值被 function 給捕獲並且複製一份。 因此就算後續 <code>value</code> 被改成 <code>100</code> 也不會造成影響。</p>
<pre><code class="language-cpp">void lambda_value_capture() {
    int value = 1;
    auto copy_value = [value] {
        return value;
    };
    value = 100;
    auto stored_value = copy_value();
    std::cout &lt;&lt; "stored_value = " &lt;&lt; stored_value &lt;&lt; std::endl;
    // At this moment, stored_value == 1, and value == 100.
    // Because copy_value has copied when its was created.
}
</code></pre>
<p>Capture list 的格式如下：</p>
<ul>
<li><code>[]</code> 空清單</li>
<li><code>[name1, name2, ...]</code> 最常見，捕獲一系列變數</li>
<li><code>[&amp;]</code> 捕獲外部參考（copy by reference），讓編譯器自行推斷要捕獲誰</li>
<li><code>[=]</code> 捕獲外部值（copy by value），讓編譯器自行推斷要捕獲誰</li>
</ul>
<p>C++14 加入可以在 capture list 中寫 expression 的能力：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;memory&gt;  // std::make_unique
#include &lt;utility&gt; // std::move

void lambda_expression_capture() {
    auto important = std::make_unique&lt;int&gt;(1);
    auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -&gt; int {
        return x+y+v1+(*v2);
    };
    std::cout &lt;&lt; add(3,4) &lt;&lt; std::endl;
}
</code></pre>
<p>C++14 開始可以在 lambda 使用 <code>auto</code> ：</p>
<pre><code class="language-cpp">auto add = [](auto x, auto y) {
    return x+y;
};

add(1, 2);
add(1.1, 2.2);
</code></pre>
<p>C++11 加入 <code>std::function</code>，正式明確定義 function 為一種型別：</p>
<pre><code class="language-cpp">#include &lt;functional&gt;
#include &lt;iostream&gt;

int foo(int para) {
    return para;
}

int main() {
    // std::function wraps a function that take int paremeter and returns int value
    std::function&lt;int(int)&gt; func = foo;

    int important = 10;
    std::function&lt;int(int)&gt; func2 = [&amp;](int value) -&gt; int {
        return 1+value+important;
    };
    std::cout &lt;&lt; func(10) &lt;&lt; std::endl;
    std::cout &lt;&lt; func2(10) &lt;&lt; std::endl;
}
</code></pre>
<p>另外也加入了 <code>std::bind</code> 與 <code>std::placeholder</code>，用以延後傳遞參數的時機：</p>
<pre><code class="language-cpp">int foo(int a, int b, int c) {
    ;
}
int main() {
    // bind parameter 1, 2 on function foo,
    // and use std::placeholders::_1 as placeholder for the first parameter.
    auto bindFoo = std::bind(foo, std::placeholders::_1, 1,2);
    // when call bindFoo, we only need one param left
    bindFoo(1);
}
</code></pre>
<h2 id="stdmove"><a class="header" href="#stdmove"><code>std::move</code></a></h2>
<p>C++11 加入了右值參考 <code>T &amp;&amp;</code> 的概念，用途是可以將一個即將被銷毀的數值轉移到另一個變數。</p>
<p><code>std::move</code> 提供了將一個左值轉換為右值參考的能力，一旦在 expression 中的右側出現了右值參考，C++ 便不會呼叫 copy constructor，而是改呼叫 move constructor (編譯器預設會實作一個)。</p>
<p>Move constructor 的概念是盡可能地只複製 pointer，而不是整份資料，並同時將舊物件內的 pointer 清除（改成 <code>nullptr</code> ），以避免大量資料被複製的行為發生，這也是 <code>std::move</code> 最常見的用途。</p>
<p>考慮以下例子：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
swap(T&amp; a, T&amp; b) {
    T tmp(a);   // we've made a second copy of a
    a = b;      // we've made a second copy of b (and discarded a copy of a)
    b = tmp;    // we've made a second copy of tmp (and discarded a copy of b)
}
</code></pre>
<p>在這個例子中，發生了三次資料複製。</p>
<p>我們可以使用 <code>std::move</code> 改寫來避免複製資料：</p>
<pre><code class="language-cpp">template &lt;class T&gt;
swap(T&amp; a, T&amp; b) {
    T tmp(std::move(a));
    a = std::move(b);   
    b = std::move(tmp);
}
</code></pre>
<p>如果 <code>T</code> 是一個資料結構，例如 <code>vector&lt;int&gt;</code> ，那裡面可能就包含大量資料，用第一版就會浪費大量的資源與時間。</p>
<p>如同 copy constructor，預設 compiler 會幫每一個型別實作一個 move constructor，作法基本上跟 copy constructor 差不多。只差在他不會複製指標指向的資料，而是單純將指標複製一份（做 shallow copy 而非 deep copy）。同時也會修改原本 class 的 member，把所有變數都清空（避免跟 moved 後的物件使用到相同的記憶體空間）。</p>
<h2 id="新增的-containers"><a class="header" href="#新增的-containers">新增的 Containers</a></h2>
<ul>
<li>
<p><code>std::array</code></p>
<ul>
<li>威力加強版的 array，提供了一些 container 的額外功能：</li>
</ul>
<pre><code class="language-cpp">std::array&lt;int, 4&gt; arr = {1, 2, 3, 4};

arr.empty(); // check if container is empty
arr.size();  // return the size of the container

// iterator support
for (auto &amp;i : arr)
{
    // ...
}

// use lambda expression for sort
std::sort(arr.begin(), arr.end(), [](int a, int b) {
    return b &lt; a;
});

// illegal, different than C-style array, std::array will not deduce to T*
// int *arr_p = arr;
</code></pre>
</li>
<li>
<p><code>std::forward_list</code></p>
<ul>
<li>只有單向的 linked list</li>
</ul>
</li>
<li>
<p><code>unordered_set</code> / <code>unordered_map</code> 跟其他東西</p>
<ul>
<li>Hash map 基底的實作，提供 O(1) 插入與查找</li>
</ul>
</li>
<li>
<p><code>std::tuple</code></p>
<ul>
<li><code>std::pair</code> 威力加強版，允許任意數量的組合</li>
<li>常用 function
<ul>
<li><code>std::get</code>: Get the value of a position in the tuple</li>
<li><code>std::tie</code>: tuple unpacking</li>
</ul>
</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
 
std::tuple&lt;double, char, std::string&gt; get_student(int id)
{
    switch (id)
    {
        case 0: return {3.8, 'A', "Lisa Simpson"};
        case 1: return {2.9, 'C', "Milhouse Van Houten"};
        case 2: return {1.7, 'D', "Ralph Wiggum"};
        case 3: return {0.6, 'F', "Bart Simpson"};
    }
 
    throw std::invalid_argument("id");
}
 
int main()
{
    const auto student0 = get_student(0);
    std::cout &lt;&lt; "ID: 0, "
              &lt;&lt; "GPA: " &lt;&lt; std::get&lt;0&gt;(student0) &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; std::get&lt;1&gt;(student0) &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; std::get&lt;2&gt;(student0) &lt;&lt; '\n';
 
    const auto student1 = get_student(1);
    std::cout &lt;&lt; "ID: 1, "
              &lt;&lt; "GPA: " &lt;&lt; std::get&lt;double&gt;(student1) &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; std::get&lt;char&gt;(student1) &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; std::get&lt;std::string&gt;(student1) &lt;&lt; '\n';
 
    double gpa2;
    char grade2;
    std::string name2;
    std::tie(gpa2, grade2, name2) = get_student(2);
    std::cout &lt;&lt; "ID: 2, "
              &lt;&lt; "GPA: " &lt;&lt; gpa2 &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; grade2 &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; name2 &lt;&lt; '\n';
 
    // C++17 structured binding:
    const auto [gpa3, grade3, name3] = get_student(3);
    std::cout &lt;&lt; "ID: 3, "
              &lt;&lt; "GPA: " &lt;&lt; gpa3 &lt;&lt; ", "
              &lt;&lt; "grade: " &lt;&lt; grade3 &lt;&lt; ", "
              &lt;&lt; "name: " &lt;&lt; name3 &lt;&lt; '\n';
}
</code></pre>
</li>
</ul>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h2>
<p>Smart pointer 的加入大幅改進了 C++ 管理記憶體的彈性。以往 C++ 開發者如果沒有正確使用 pointer，則可能會造成該 pointer 指向非法空間 (segmentation fault) 或者 memory leak 等常見問題。如果 C++ 開發者使用 smart pointer，C++ 就能夠自動進行記憶體管理，並在適當的時機釋放該釋放的記憶體。</p>
<ul>
<li>
<p><code>std::shared_ptr</code> : 使用計數器管理記憶體的 pointer。</p>
<ul>
<li>原理：每次複製 pointer 時都會造成內部的計數器加一，pointer 被銷毀時計數器減一，當計數器歸零時（即所有的 pointer 都被銷毀時），就會自動釋放背後物件的記憶體空間。
<pre><code class="language-cpp">auto pointer = std::make_shared&lt;int&gt;(10);
auto pointer2 = pointer; // reference count+1
auto pointer3 = pointer; // reference count+1
int *p = pointer.get();  // no increase of reference count

std::cout &lt;&lt; "pointer.use_count() = " &lt;&lt; pointer.use_count() &lt;&lt; std::endl;   // 3
std::cout &lt;&lt; "pointer2.use_count() = " &lt;&lt; pointer2.use_count() &lt;&lt; std::endl; // 3
std::cout &lt;&lt; "pointer3.use_count() = " &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 3

pointer2.reset();
std::cout &lt;&lt; "reset pointer2:" &lt;&lt; std::endl;

std::cout &lt;&lt; "pointer.use_count() = " &lt;&lt; pointer.use_count() &lt;&lt; std::endl;   // 2
std::cout &lt;&lt; "pointer2.use_count() = " 
    &lt;&lt; pointer2.use_count() &lt;&lt; std::endl;                // pointer2 has reset, 0
std::cout &lt;&lt; "pointer3.use_count() = " &lt;&lt; pointer3.use_count() &lt;&lt; std::endl; // 2
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>std::unique_ptr</code> : 不能被複製只能 move 的 pointer。</p>
<ul>
<li>
<p>原理：當每次進行 pointer assignment 的行為時，被限定只能用 move 而不能複製的 pointer。舊的 pointer 在 move 完後會當即失效，無法繼續使用。而當這個唯一的 pointer 被銷毀時，背後物件的記憶體也會跟著被釋放。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; // std::cout
#include &lt;memory&gt;

int main()
{
  auto pointer = std::make_unique&lt;int&gt;(10);  // make_unique, from C++14
  // auto pointer2 = pointer;                // copy is illegal
  auto pointer3 = std::move(pointer);        // move is OK
  std::cout &lt;&lt; pointer &lt;&lt; std::endl;
  std::cout &lt;&lt; pointer3 &lt;&lt; std::endl;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>std::weak_ptr</code> : 弱指針，針對 <code>shared_ptr</code> 設計，建立時不會引起計數器加一。</p>
<ul>
<li>
<p><code>shared_ptr</code> 有個常見的問題是，如果有兩個 <code>shared_ptr</code> 互相指向對方，那麼就會造成計數器永遠不會變成 0：</p>
<p><img src="weak-pointer.png" alt="Cycle Share" /></p>
<ul>
<li>因此這時通常會讓其中一個 pointer 改成用 <code>weak_ptr</code>，這樣就 <code>shared_ptr</code> 就可以正常歸零。</li>
</ul>
</li>
<li>
<p>用法：直接 assign <code>shared_ptr</code> 給 <code>weak_ptr</code> 即可</p>
<pre><code class="language-cpp">std::shared_ptr&lt;int&gt; a = std::make_shared&lt;int&gt;(42);
std::weak_ptr&lt;int&gt; b = a;
</code></pre>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-concurrency"><a class="header" href="#c-concurrency">C++ Concurrency</a></h1>
<h2 id="stdthread"><a class="header" href="#stdthread"><code>std::thread</code></a></h2>
<p>C++11 引入了標準的 thread 函式庫，用法如下：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

int main() {
    std::thread t([](){
        std::cout &lt;&lt; "hello world." &lt;&lt; std::endl;
    });
    t.join();
    return 0;
}
</code></pre>
<h2 id="locks"><a class="header" href="#locks">Locks</a></h2>
<ul>
<li><code>std::mutex</code> :  lock 的基本元件，提供 lock 與 unlock 功能建立 critical section
<ul>
<li>不建議直接使用，因為需要記得手動 lock 與 unlock</li>
</ul>
</li>
<li><code>std::lock_guard</code> : <code>std::mutex</code> 的 wrapper，創建時自動 lock mutex，解構時自動 unlock</li>
<li><code>std::unique_lock</code> : <code>std::mutex</code> 的 wrapper，創建時自動 lock，中途可以選擇 unlock 並再度 lock，解構時會自動 unlock
<ul>
<li>
<p>建議優先選擇用這個</p>
</li>
<li>
<p>範例：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

int v = 1;

void critical_section(int change_v) {
    static std::mutex mtx;
    std::unique_lock&lt;std::mutex&gt; lock(mtx);
    // do contention operations
    v = change_v;
    std::cout &lt;&lt; v &lt;&lt; std::endl;
    // release the lock
    lock.unlock();

    // during this period, others are allowed to acquire v

    // start another group of contention operations
    // lock again
    lock.lock();
    v += 1;
    std::cout &lt;&lt; v &lt;&lt; std::endl;
    // Unlock when it disappears
}

int main() {
    std::thread t1(critical_section, 2), t2(critical_section, 3);
    t1.join();
    t2.join();
    return 0;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="stdfuture"><a class="header" href="#stdfuture"><code>std::future</code></a></h2>
<p>一個用來建立 task，等待未來回收結果的 utility 元件。</p>
<p>詳情：<a href="https://changkun.de/modern-cpp/en-us/07-thread/#7-3-Future">https://changkun.de/modern-cpp/en-us/07-thread/#7-3-Future</a></p>
<h2 id="stdcondition_variable"><a class="header" href="#stdcondition_variable"><code>std::condition_variable</code></a></h2>
<p>提供 <code>wait()</code> 與 <code>notify_all()</code> 與 <code>notify_one()</code> 的功能，讓 thread 可以進入等待狀態，其他 thread 也可以叫醒等待的 thread</p>
<p>範例：<a href="https://changkun.de/modern-cpp/en-us/07-thread/#7-4-Condition-Variable">https://changkun.de/modern-cpp/en-us/07-thread/#7-4-Condition-Variable</a></p>
<h2 id="stdatomic"><a class="header" href="#stdatomic"><code>std::atomic</code></a></h2>
<p>如果想要保證一些常見操作（例如 <code>++</code>）的原子性，除了使用 <code>std::mutex</code> 建立 critical section 之外，也可以使用 <code>std::atomic</code> 。 這樣可以大幅減少要撰寫的程式碼。 下面展示使用 <code>std::atomic</code> 做出 atomic 的 <code>++</code> 操作的範例：</p>
<pre><code class="language-cpp">#include &lt;atomic&gt;
#include &lt;thread&gt;
#include &lt;iostream&gt;

std::atomic&lt;int&gt; count = {0};

int main() {
    std::thread t1([](){
        count.fetch_add(1);
    });
    std::thread t2([](){
        count++;        // identical to fetch_add
        count += 1;     // identical to fetch_add
    });
    t1.join();
    t2.join();
    std::cout &lt;&lt; count &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>因為 <code>std::atomic</code> 實際上是一個 template，可以容納任何類型的資料，因此 C++ 有提供額外的 API 檢查該類型資料是否有保障原子性：</p>
<pre><code class="language-cpp">#include &lt;atomic&gt;
#include &lt;iostream&gt;

struct A {
    float x;
    int y;
    long long z;
};

int main() {
    std::atomic&lt;A&gt; a;
    std::cout &lt;&lt; std::boolalpha &lt;&lt; a.is_lock_free() &lt;&lt; std::endl;
    return 0;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
